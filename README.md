# Problem Statement

Corewar consists of programs that run in a virtual machine. Each program's objective is to execute a special instruction ("live"), given each program task orientation. These programs simultaneously execute in the virtual machine and in the same memory zone, which enables them to write on one another.

The project must be coded in C - ðŸ˜Ž The project is divided into three separate parts:

### Virtual Machine
It's the sandbox environment where the programs will run. It must offer all features that are useful for programs to run. It must be able to execute multiple programs.

### Assembler
It's the core of syntax and rules to make a valid program. It must be able to generate binary code executable by the Virtual Machine.

### Programs
Must be able to run and leave the virtual machine. They are written in the assembly language specific to the virtual machine.

### Solution

#### Virtual Machine
- REG_NUMBER registers of REG_SIZE byte search
- A register is a memory zone that contains only one value. In a real machine, it is embedded within the processor and can be accessed very fast. REG_NUMBER and REG_SIZE are defined in op.h.
- A C(Counter)
  - This register contains the memory address (in the virtual machine) of the next instruction to be decoded and executed. This is useful to know where you are and to write things in memory.
- Unset Carry Flag
  - This flag is worth one if, and only if, the last operation returned zero.

The machineâ€™s role is to execute programs passed as parameters, generating processes. It must check that each process calls the "live" instruction every CYCLE_TO_DIE cycles. If, after NBR_LIVE executions of the instruction live, several processes are still alive, CYCLE_TO_DIE is decreased by CYCLE_DELTA units. This starts over until there are no live processes left.

```bash
~/QWASAR-MSCS>./corewar -h
USAGE
./corewar [-dump nbr_cycle] [[-n prog_number] [-a load_address] prog_name] ...
```

#### Output
Each program has a number. This number is generated by the virtual machine and is given to the programs in the r1 register at the machine startup (all others will be initialized at 0). With each execution of the "live" instruction, the machine must display "The program NBR_OF_PROGRAM(NAME_OF_PROGRAM) is alive." When a player wins, the machine must display "The player NBR_OF_PROGRAM (NAME_OF_PROGRAM) is done.".

#### Scheduling
The Virtual Machine emulates a parallel machine. As an implementation constraint, it is assumed that each instruction executes entirely at the end of its last cycle and waits for its entire duration. The instructions that start on the same cycle are executed according to the programâ€™s number, in ascending order.

Letâ€™s consider 3 programs (P1, P2, and P3), each consisting of the respective instructions 1.1 1.2 .. 1.7, 2.1 .. 2.7, and 3.1 .. 3.7. The timing of each instruction would look like this:

```plaintext
Instruction cycles
Virtual Machine Order of execution
...
```

#### Machine Code
The machine must recognize the instructions below. If not a valid command, the Virtual machine moves to the next instruction.

```plaintext
MNEMONIC EFFECT
0X01 (live) Takes 1 parameter: 4 bytes that represent the player's number.
...
```

#### Assembler
The virtual machine job is to execute machine code. The assembler is responsible for setting the rules and syntax for writing the programs. We shall call it simply GAC (General Assembly Code).

Instructions are made of 3 elements:
- Label: An optional label, followed by the LABEL_CHAR character (here,":") declared in op.h.
- Opcode: An instruction code.
- Parameters: Instructions can have from 0 to MAX_ARGS_NUMBER parameters, separated by a comma.

Parameters can be:
- Register: From r1 to rREG_NUMBER.
- Direct: The DIRECT_CHAR character, followed by a value or a label (preceded by LABEL_CHAR).
- Indirect: A value or a label (preceded by LABEL_CHAR), which represents the value found at the parameterâ€™s address (in relation to the Counter).

The assembler takes an instruction file in assembly code (the program) as a parameter and produces an executable for the virtual machine by converting its assembly code into machine code.

```bash
~/QWASAR-MSCS>./asm -h
USAGE
./asm file_name[.s]
```

#### Coding
Each instruction is composed of three elements:
- Instruction code
- Description of parameter types, except for the following instructions: live, zjmp, fork, fork.
- Parameters

Examples:
```assembly
sti r2, 23, %34
```

- Instruction code: 00 00 10 11 = 0x0b (Hex. representation)
- Param. Description: 01 11 10 00 = 0x78 (Hex. representation)

Values: 0x02 0x00 0x17 0x00 0x00 0x00 0x22

Full Instruction (in Hexadecimal): 0b 78 02 00 17 00 00 00 22

#### Programs
Programs are written in GAC (General Assembly Code) assembly language, described in The Assembler section. When the virtual machine starts, each program is going to find its personal r1 register (the number assigned to it by the Virtual Machine).

#### Scenarios
**Simple**
```assembly
.name "Simple"
.comment "Let's get started"
l2: sti r1,%:live,%1
and r1,%0,r1
live: live %1
zjmp %:live
```

**Complex**
```assembly
.name "Complex"
.comment "Let's do it!"
sti r1,%:live,%1
sti r1,%:live2,%1
ld %1,r3
ld %33,r6
#While (r2 < 10)
forks:
add r2,r3,r2 #increment r2
xor r2,%15,r4 #if (r4) {carry = 0}
live2:
live %4
zjmp %:endwhile #if (carry)
fork %:forks
ld %0,r4 #carry = 1
zjmp %:forks
#EndWhile
endwhile:
ld %0,r4 #carry = 1
live:
live %4
zjmp %:live
```

#### op.h
```c
#ifndef _OP_H_
#define _OP_H_
...
```

#### op.c
```c
#include "corewar.h"
const op_t op_tab[] = {
    {"live", 1, {T_DIR}, 1, 10, inst_live},
    {"ld", 2, {T_DIR | T_IND, T_REG}, 2, 5, inst_ld},
    ...
};
...
```

#### References
- CoreWar - Origins

#### Authorized Functions
- (f)open
- read
- write
- getline
- lseek
- fseek
- (f)close


- malloc
- realloc
- free
- exit